<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>welcome</title>
  <style>
    /* Perfect blue background */
    body {
      margin: 0;
      overflow: hidden;
      background-color: #0000FF;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // Wrap everything in an IIFE to avoid global namespace pollution.
    (function() {
      // === Canvas Setup ===
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // === Global Variables for Pointer Tracking ===
      // This will store the current mouse/touch position.
      let pointer = null;
      // Update pointer on mouse move.
      document.addEventListener("mousemove", function(e) {
        pointer = { x: e.clientX, y: e.clientY };
      });
      // For touch devices.
      document.addEventListener("touchmove", function(e) {
        if (e.touches.length > 0) {
          pointer = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      });
      // Clear pointer on touch end.
      document.addEventListener("touchend", function() {
        pointer = null;
      });

      // === Vector Class ===
      class Vector {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        add(v) {
          this.x += v.x;
          this.y += v.y;
          return this;
        }
        sub(v) {
          this.x -= v.x;
          this.y -= v.y;
          return this;
        }
        mult(n) {
          this.x *= n;
          this.y *= n;
          return this;
        }
        div(n) {
          this.x /= n;
          this.y /= n;
          return this;
        }
        mag() {
          return Math.hypot(this.x, this.y);
        }
        normalize() {
          let m = this.mag();
          if (m !== 0) this.div(m);
          return this;
        }
        setMag(n) {
          this.normalize();
          this.mult(n);
          return this;
        }
        limit(max) {
          if (this.mag() > max) this.setMag(max);
          return this;
        }
        copy() {
          return new Vector(this.x, this.y);
        }
        static sub(v1, v2) {
          return new Vector(v1.x - v2.x, v1.y - v2.y);
        }
      }

      // === Boid Class ===
      class Boid {
        constructor(x, y) {
          this.position = new Vector(x, y);
          // Start with a random velocity.
          let angle = Math.random() * 2 * Math.PI;
          this.velocity = new Vector(Math.cos(angle), Math.sin(angle)).setMag(2);
          this.acceleration = new Vector(0, 0);
          this.maxSpeed = 4;
          this.maxForce = 0.05;
        }
        // Wrap around the edges of the canvas.
        edges() {
          if (this.position.x > canvas.width) this.position.x = 0;
          if (this.position.x < 0) this.position.x = canvas.width;
          if (this.position.y > canvas.height) this.position.y = 0;
          if (this.position.y < 0) this.position.y = canvas.height;
        }
        // Flocking behavior: alignment, cohesion, separation.
        flock(boids) {
          let perception = 75;
          let alignment = new Vector(0, 0);
          let cohesion = new Vector(0, 0);
          let separation = new Vector(0, 0);
          let total = 0;
          for (let other of boids) {
            let d = Vector.sub(this.position, other.position).mag();
            if (other !== this && d < perception) {
              alignment.add(other.velocity);
              cohesion.add(other.position);
              let diff = Vector.sub(this.position, other.position);
              diff.div(d);
              separation.add(diff);
              total++;
            }
          }
          if (total > 0) {
            alignment.div(total);
            alignment.setMag(this.maxSpeed);
            alignment.sub(this.velocity);
            alignment.limit(this.maxForce);

            cohesion.div(total);
            cohesion.sub(this.position);
            cohesion.setMag(this.maxSpeed);
            cohesion.sub(this.velocity);
            cohesion.limit(this.maxForce);

            separation.div(total);
            separation.setMag(this.maxSpeed);
            separation.sub(this.velocity);
            separation.limit(this.maxForce);
          }
          this.acceleration.add(alignment.mult(0.7));
          this.acceleration.add(cohesion.mult(0.7));
          this.acceleration.add(separation.mult(1.5));
        }
        // Update boid position.
        update() {
          this.velocity.add(this.acceleration);
          this.velocity.limit(this.maxSpeed);
          this.position.add(this.velocity);
          this.acceleration.mult(0);
        }
        // Draw the boid as a small triangle.
        draw(ctx) {
          let angle = Math.atan2(this.velocity.y, this.velocity.x);
          ctx.save();
          ctx.translate(this.position.x, this.position.y);
          ctx.rotate(angle);
          ctx.beginPath();
          // Smaller boid shape.
          ctx.moveTo(6, 0);
          ctx.lineTo(-3, 2);
          ctx.lineTo(-3, -2);
          ctx.closePath();
          ctx.fillStyle = "white";
          ctx.fill();
          ctx.restore();
        }
      }

      // === Create Boids ===
      const boids = [];
      const numBoids = 1000;
      for (let i = 0; i < numBoids; i++) {
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        boids.push(new Boid(x, y));
      }

      // === Mouse/Touch Attraction ===
      // In the animation loop, we'll add a slight attraction force toward the pointer.
      function applyPointerAttraction(boid) {
        if (pointer) {
          let target = new Vector(pointer.x, pointer.y);
          let desired = Vector.sub(target, boid.position);
          let d = desired.mag();
          desired.normalize();
          // The strength of the attraction decreases with distance.
          let strength = 0.05;
          desired.mult(strength);
          boid.acceleration.add(desired);
        }
      }

      // === Main Animation Loop ===
      function animate() {
        requestAnimationFrame(animate);
        ctx.fillStyle = "#0000FF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        boids.forEach(boid => {
          boid.flock(boids);
          // Apply pointer attraction if available.
          applyPointerAttraction(boid);
          boid.update();
          boid.edges();
          boid.draw(ctx);
        });
      }
      animate();
    })();
  </script>
</body>
</html>
