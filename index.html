<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Boids Word Formation Sequence</title>
  <style>
    /* Perfect blue background */
    body {
      margin: 0;
      overflow: hidden;
      background-color: #0000FF;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    (function() {
      // === Canvas Setup ===
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // When resizing, re-compute formations.
        formations = words.map(word => createFormationPoints(word));
      }
      
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      
      // === Global Variables & State ===
      // Declare words first so they’re available for functions.
      const words = ["WELCOME", "TO", "MY", "PAGE"];
      let formations = [];  // Will be computed below.
      let currentWordIndex = 0;  // Which word to form next.
      let formationActive = false; // false = free flocking, true = forming word.
      
      // === Vector Class ===
      class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { this.x += v.x; this.y += v.y; return this; }
        sub(v) { this.x -= v.x; this.y -= v.y; return this; }
        mult(n) { this.x *= n; this.y *= n; return this; }
        div(n) { this.x /= n; this.y /= n; return this; }
        mag() { return Math.hypot(this.x, this.y); }
        normalize() { const m = this.mag(); if (m !== 0) this.div(m); return this; }
        setMag(n) { this.normalize(); this.mult(n); return this; }
        limit(max) { if (this.mag() > max) this.setMag(max); return this; }
        copy() { return new Vector(this.x, this.y); }
        static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
      }
      
      // === Boid Class ===
      class Boid {
        constructor(x, y) {
          this.position = new Vector(x, y);
          let angle = Math.random() * 2 * Math.PI;
          this.velocity = new Vector(Math.cos(angle), Math.sin(angle)).setMag(2);
          this.acceleration = new Vector(0, 0);
          this.maxSpeed = 4;
          this.maxForce = 0.05;
          // formationTarget will be updated when formation mode is active.
          this.formationTarget = { x: x, y: y };
        }
        // Wrap around the edges.
        edges() {
          if (this.position.x > canvas.width) this.position.x = 0;
          if (this.position.x < 0) this.position.x = canvas.width;
          if (this.position.y > canvas.height) this.position.y = 0;
          if (this.position.y < 0) this.position.y = canvas.height;
        }
        // Free flocking behavior (alignment, cohesion, separation).
        flock(boids) {
          let perception = 75;
          let alignment = new Vector(0, 0);
          let cohesion = new Vector(0, 0);
          let separation = new Vector(0, 0);
          let total = 0;
          for (let other of boids) {
            let d = Vector.sub(this.position, other.position).mag();
            if (other !== this && d < perception) {
              alignment.add(other.velocity);
              cohesion.add(other.position);
              let diff = Vector.sub(this.position, other.position);
              diff.div(d);
              separation.add(diff);
              total++;
            }
          }
          if (total > 0) {
            alignment.div(total).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce);
            cohesion.div(total).sub(this.position).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce);
            separation.div(total).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce);
          }
          this.acceleration.add(alignment.mult(0.7));
          this.acceleration.add(cohesion.mult(0.7));
          this.acceleration.add(separation.mult(1.5));
        }
        // Formation steering: steer toward the formation target at reduced speed.
        formationSteer() {
          let target = new Vector(this.formationTarget.x, this.formationTarget.y);
          let desired = Vector.sub(target, this.position);
          let d = desired.mag();
          desired.normalize();
          let formSpeed = this.maxSpeed * 0.3;
          if (d < 100) {
            desired.mult(formSpeed * (d / 100));
          } else {
            desired.mult(formSpeed);
          }
          let steer = Vector.sub(desired, this.velocity);
          steer.limit(this.maxForce * 5);
          this.acceleration.add(steer);
        }
        update() {
          this.velocity.add(this.acceleration);
          this.velocity.limit(this.maxSpeed);
          this.position.add(this.velocity);
          this.acceleration.mult(0);
        }
        draw(ctx) {
          let angle = Math.atan2(this.velocity.y, this.velocity.x);
          ctx.save();
          ctx.translate(this.position.x, this.position.y);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(8, 0);
          ctx.lineTo(-4, 3);
          ctx.lineTo(0, 0);
          ctx.lineTo(-4, -3);
          ctx.closePath();
          ctx.fillStyle = "black";
          ctx.fill();
          ctx.restore();
        }
      }
      
      // === Formation Points Generator ===
      // Draw the given word on an off-screen canvas and sample every pixel.
      // Offscreen canvas width is half of the main canvas width; height is offWidth * 0.5.
      function createFormationPoints(word) {
        const offWidth = canvas.width / 2;
        const offHeight = offWidth * 0.5;  // Adjust aspect ratio as desired.
        const offCanvas = document.createElement("canvas");
        offCanvas.width = offWidth;
        offCanvas.height = offHeight;
        const offCtx = offCanvas.getContext("2d");
        offCtx.clearRect(0, 0, offWidth, offHeight);
        offCtx.fillStyle = "black";
        offCtx.textAlign = "center";
        offCtx.textBaseline = "middle";
        offCtx.font = "bold 350px sans-serif";
        offCtx.fillText(word, offWidth / 2, offHeight / 2);
        const imageData = offCtx.getImageData(0, 0, offWidth, offHeight);
        const data = imageData.data;
        const points = [];
        // Sample every 1 pixel for maximum density.
        for (let y = 0; y < offHeight; y++) {
          for (let x = 0; x < offWidth; x++) {
            let idx = (y * offWidth + x) * 4;
            if (data[idx + 3] > 128) {
              // Map the point: center horizontally; add a top margin (50px).
              points.push({
                x: x + (canvas.width - offWidth) / 2,
                y: y + 50
              });
            }
          }
        }
        return points;
      }
      
      // === Create Formations for Each Word ===
      formations = words.map(word => createFormationPoints(word));
      
      // === Create Boids ===
      const boids = [];
      const numBoids = 1000;
      // Start with free flocking (random positions).
      for (let i = 0; i < numBoids; i++) {
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        boids.push(new Boid(x, y));
      }
      
      // === Global Transition Functions ===
      // Update each boid's formation target based on the current formation.
      function updateBoidsFormationTargets() {
        const currentFormation = formations[currentWordIndex];
        boids.forEach((boid, i) => {
          let pt = currentFormation[i % currentFormation.length];
          boid.formationTarget = { x: pt.x, y: pt.y };
        });
      }
      
      // Start formation: switch to formation mode, update targets, and hold for 2 seconds.
      function startFormation() {
        formationActive = true;
        updateBoidsFormationTargets();
        setTimeout(endFormation, 2000);
      }
      
      // End formation: switch back to free flocking; scatter boids.
      function endFormation() {
        formationActive = false;
        boids.forEach(boid => {
          let randAngle = Math.random() * 2 * Math.PI;
          boid.velocity = new Vector(Math.cos(randAngle), Math.sin(randAngle)).setMag(2);
        });
        // After 10 seconds of free flocking, schedule next formation.
        setTimeout(scheduleNextFormation, 10000);
      }
      
      // Schedule next formation: wait a random delay (15–25 seconds), then form the next word.
      function scheduleNextFormation() {
        currentWordIndex = (currentWordIndex + 1) % formations.length;
        let delay = 15000 + Math.random() * 10000;
        setTimeout(startFormation, delay);
      }
      
      // Initially, let boids flock freely; after an initial delay, start formation.
      let initialDelay = 15000 + Math.random() * 10000;
      setTimeout(startFormation, initialDelay);
      
      // === Main Animation Loop ===
      function animate() {
        requestAnimationFrame(animate);
        ctx.fillStyle = "#0000FF"; // Perfect blue background.
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        boids.forEach(boid => {
          if (formationActive) {
            boid.formationSteer();
          } else {
            boid.flock(boids);
          }
          boid.update();
          boid.edges();
          boid.draw(ctx);
        });
      }
      animate();
    })();
  </script>
</body>
</html>
